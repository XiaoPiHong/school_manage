"use strict";(self["webpackChunkschool_manage_ts"]=self["webpackChunkschool_manage_ts"]||[]).push([[941],{6941:function(e,t,s){s.r(t),s.d(t,{default:function(){return d}});var o=function(){var e=this,t=e._self._c;e._self._setupProxy;return t("div",[t("Row",{staticClass:"pd10 deep-com-row"},[t("Col",{attrs:{span:"24"}},[t("h4",[e._v("理解scoped原理")]),t("p",[e._v(" 1.当你想私有当前组件的样式，vue组件中可以使用scoped属性，scoped底层是通过在DOM节点中添加data-v-xxx，CSS中通过添加[data-v-xxx]属性过滤，提高优先级，来实现样式的私有化； ")]),t("p",[e._v(" 2.当前组件使用了scoped时，会在当前vue组件的根元素 和 子孙组件的根元素 和当前vue组件的html标签上 加上data-v-xxx属性； ")])]),t("Col",{attrs:{span:"24"}},[t("h4",[e._v("何时使用样式穿透deep")]),t("p",[e._v(" 1.当你想修改一个组件内部的元素样式，但是该元素并不是当前vue组件的根元素， 也不是当前vue组件的子孙组件的根元素，也不是当前vue组件的html标签时就要使用样式穿透 ")]),t("p",[e._v(" 2.一般来说要想修改当前vue组件引用的组件的内部样式，我们就使用样式穿透，这样可以让别人快速知道当前的这个类名或者其他的css选择器是属于当前引用的这个组件的 ")])]),t("Col",{attrs:{span:"24"}},[t("Row",[t("Col",{attrs:{span:"24"}},[t("h5",[e._v("测试标题")]),t("div",[e._v(" 1.测试内容 "),t("Input",{attrs:{placeholder:"Enter something..."}})],1)])],1)],1)],1)],1)},n=[],a=s(9203),r=function(e,t,s,o){var n,a=arguments.length,r=a<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,s):o;if("object"===typeof Reflect&&"function"===typeof Reflect.decorate)r=Reflect.decorate(e,t,s,o);else for(var c=e.length-1;c>=0;c--)(n=e[c])&&(r=(a<3?n(r):a>3?n(t,s,r):n(t,s))||r);return a>3&&r&&Object.defineProperty(t,s,r),r};let c=class extends a.w3{};c=r([(0,a.wA)({name:"DeepCom",components:{}})],c);var l=c,p=l,u=s(3736),v=(0,u.Z)(p,o,n,!1,null,"4f84dd82",null),d=v.exports}}]);